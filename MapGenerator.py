from PIL import Image
import os
import math

class Map():
    """
    Simple Map object
    tiles can be generated by passing Map to MapGenerator
    =====================================
    1 : Get original map dimension
    - dimensions

    2 : Check if original map dimension is 
    Wider than long or the reverse (ratioPriority)
    - ratioPriority

    3 : Get Smallest map dimension into a tiles
    by reduce the bigger side (ratioPriority)
    to get both side inside the tile size
    - smallestDimensions
    - _calculateDimensions

    4 : Calcul number zoom from smallest map to biggest 
    with zoomFactor without exceed limit of original map
    get the list of all dimensions Map calculated
    - zMapDimensions
    """

    def __init__(self, src, nb_zoom=None, tileSize=None, sizeFactor=None):
        self.image = Image.open(src)
        self.ext = self.image.filename.split('.')[1]
        self.sizeFactor = sizeFactor if sizeFactor else 2
        self.tileSize = tileSize if tileSize else 256
        self.hookGen = None
        self.progress = 0

    @property
    def ratio(self):
        if(self.image.width > self.image.height):	
            return self.image.width/self.image.height
        return self.image.height/self.image.width

    @property
    def ratioPriority(self):
        if(self.image.width > self.image.height):
            return 0
        return 1

    @property
    def nb_zoom(self):
        dim, c = self.tileSize , 0
        while dim*self.sizeFactor < self.image.width:
            dim = dim * self.sizeFactor
            c += 1
        return c

    @property
    def dimensions(self):
        return (math.ceil(self.image.width), math.ceil(self.image.height))

    @property
    def smallestDimensions(self):
        return self._calculateDimensions(self.tileSize)

    @property
    def numberTilesTotal(self):
        nbTiles = 0
        for zMap in self.zMapDimensions:
            nbTiles += self.calculMapTilesNumber(zMap)
            
        return nbTiles

    @property
    def zMapDimensions(self):
        smallestDimensions = self.smallestDimensions[self.ratioPriority]
        zDimensions = [self.smallestDimensions]
        for i in range(1, self.nb_zoom):    
            zDimensions.append(self._calculateDimensions(smallestDimensions * self.sizeFactor * i))
        zDimensions.append(self.dimensions)
        return zDimensions


    def calculNumberTiles(self, dimensions, x_or_y):
        x_or_y = (x_or_y == 'y')
        return math.ceil(dimensions[x_or_y] / self.tileSize)

    def calculMapTilesNumber(self, dimensions):
        nbTiles0 = math.ceil(dimensions[0] / self.tileSize) 
        nbTiles1 = math.ceil(dimensions[1] / self.tileSize)
        return nbTiles0 * nbTiles1

    def _calculateDimensions(self, newDimension):
        dimensions = [0, 0]
        dimensions[self.ratioPriority] = math.ceil(newDimension)
        dimensions[1 - self.ratioPriority] = math.ceil(self._calculDimFromProp(newDimension))
        return tuple(dimensions)

    def _calculDimFromProp(self, dimension):
        return dimension / self.ratio

class MapGenerator():
    """
    Generator object
    Use map object to generate all tiles
    organised in path /z/x/y.imageExtention
    =====================================
    """

    def __init__(self, map):
        self.map = map
        self.genFolder = 'genZXY'

    # it's a generator for returning
    # stream of generation progress 
    def generateMapTiles(self):
        progress = 0
        self.makeFolderGen()
        for tile in self.genTilesTreeZXY(self._genZ, self._genX, self._genY):
            tile[0](tile)
            progress += 1
            yield progress
    
    def genTilesTreeZXY(self, actionZ=None, actionX=None, actionY=None):
        for z, zMap in enumerate(self.map.zMapDimensions):
            posX , posY = 0 , 0
            yield [actionZ, z]
            for x in range(0, self.map.calculNumberTiles(self.map.zMapDimensions[z], 'x')):
                posY = 0
                yield [actionX, z, x]
                for y in range(0, self.map.calculNumberTiles(self.map.zMapDimensions[z], 'y')):
                    yield [actionY, z, x, y, (posX, posY)]
                    posY += self.map.tileSize
                posX += self.map.tileSize

    def makeFolderGen(self, path=''):
        folder = os.path.join(self.genFolder, path)
        if not os.path.isdir(folder):
            os.mkdir(folder)

    def _genZ(self, tile):
        """
        When we arrive to new zoom, we create new z folder
        and save in z folder , the resized image of map 
        """ 
        prior = self.map.ratioPriority
        dim1 = self.map.zMapDimensions[tile[1]][prior]
        dim2 = self.map.zMapDimensions[tile[1]][prior-1]
        self.makeFolderGen(str(tile[1]))
        croped = self.map.image.resize((dim1, dim2), Image.ANTIALIAS)
        croped.save(os.path.join(self.genFolder, str(tile[1]), 'map'+ "." + self.map.ext))
    
    def _genX(self, tile):
        """
        When we arrive to new x column, we create new z/x/ folder
        """
        self.makeFolderGen(os.path.join(str(tile[1]), str(tile[2])))

    def _genY(self, tile):
        """
        For each Y row, we create a tile croped 
        from current map of current zoom
        """
        t, tz = tile, self.map.tileSize
        pathMap = os.path.join(self.genFolder,str(t[1]), "map." + self.map.ext)
        path_zxy = os.path.join(str(t[1]),str(t[2]), str(t[3]))
        pathImage = os.path.join(self.genFolder, path_zxy + "." + self.map.ext)
        cropZone = (t[4][0], t[4][1], tz + t[4][0], tz + t[4][1])
        tileMap = Image.open(pathMap)

        tileCroped = tileMap.crop(cropZone)
        tileCroped.save(pathImage)
        tileMap.close()